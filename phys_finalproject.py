# -*- coding: utf-8 -*-
"""Phys_FinalProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YG4W7RYcSqbYCjoQwTsQEmhggDSmRgfn
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.integrate import solve_ivp

"""mass: mass (in solar masses M⊙)
logg: base-10 logarithm of the surface gravity in CGS units 
"""

def read_data(filename, delim):
  '''
  Input: 
    Directory to the file to be read
    Type of delimiter used in the file

  Output:
    A numpy array composed of all log(g) and mass values in the dataset.
  '''
  data = pd.read_csv(filename, sep = delim)
  return data[['logg', 'mass']].to_numpy()

  
def unit_conversion(logg, mass):
  '''
  This function converts the unit of surface gravity from CGS units to average Earth radii unit.
  '''

  # Define constants

  average_earth_radii = 6371 * 10**3 # m
  gravitation_constant = 6.6743 * 10**-11 # m3 kg-1 s-2
  solar_mass_kg = 1.98847 * 10**30 # kg

  # Convert surface gravity from CGS to SI

  surface_gravity = 10**logg * 10**-2
      
  # Convert solar mass to kg for mass
  mass_kg = solar_mass_kg * mass  

  # Radius in m is calculated from Newton's law of universal gravitation.
  # Radius in m used to convert radius of the star to average earth radii unit
  radius_m = np.sqrt(gravitation_constant * mass_kg / surface_gravity)
  radius_avgEarth = (radius_m) / average_earth_radii

  return radius_avgEarth, mass_kg, radius_m

data_file = '/content/drive/MyDrive/white_dwarf_data.csv'

data = read_data(data_file, ',')
logg = data[:, 0]
mass = data[:, 1]
plt.scatter(mass, [unit_conversion(i,j)[0] for i,j in zip(logg, mass)], color = 'orange')
plt.title('M vs R')
plt.xlabel('M (solar mass)')
plt.ylabel('R (average Earth radii)')
plt.grid()
plt.show()

"""# Q1c. 
In this section we will
  1. Fit the data to find K* and n\*
  2. Using n* and Lane-Emnde equation, find ρc
  3. Plot M vs ρc


In the Lane-Emden equation ξ is a dimensionless radius and θ is related to the density, and thus the pressure, by ρ = ρ$_{c}$θⁿ for central density ρ$_{c}$.
The index *n* is the polytropic index that appears in the polytropic equation of state,
P = K ρ$^{1+1/n}$, where P and ρ are the pressure and density respectively, and K is a constant of proportionality.

Thus, here we will start by giving q and c (proportionality constant of Eq. 7) initial values to iterate further. We will use c to find K.

We are using Eq.7 which gives the relationship between M and R
"""

def mass_radius(R, A, n):
  M  = A * (R ** ((3 - n) / (1 - n)))
  return M

def lane_emden_solver(n):   
   # We will solve lane emden equation to get propagated span of xi, 
   # theta and theta_dot. We will also deal with the end of the iteration.

    def is_surface(xi, theta, n): return theta[0]
    is_surface.terminal = True
    is_surface.direction = 0

    theta_0 = [1, 0]  # Initial value for theta
    xi_span = [0, 10]  # Initial value for xi and possible span

    r = solve_ivp(fun=lane_emden, t_span=xi_span,
                  y0=theta_0, events=is_surface, args=(n,))

    # If propagation is successful:
    if r.status >= 0:
        return r.t, r.y
    else:
        print("It seems solver is not able to obtain a solution!")

def lane_emden(xi, theta, n):
  # Write the lane emden equation to be used in the solver.
  if xi != 0:
    return np.array([theta[1], (-xi * np.power(theta[0], n, out=np.zeros_like(theta[0]), where=theta[0] > 0) - 2 * theta[1]) / (xi)])
  else:
    return [theta[1], 0]

def fit_curve(low_mass_threshold=None, low_mass = True):
  data = read_data(data_file, ',')
  logg = data[:, 0]
  mass = data[:, 1]
  radius_avgEarth, mass_kg, radius_m = unit_conversion(logg,mass)
  q_initial = 3.0
  A_initial = 9e50 
  if low_mass :
    M = mass_kg[mass < low_mass_threshold]
    R = radius_m[mass < low_mass_threshold]
  else:
    M = mass_kg
    R = radius_m
  if (A_initial is not None) and (q_initial is not None):
      # If A and q are to be optimized
      def create_fitting_function(R, A, q): 
        n = q/(5-q)
        return mass_radius(R = R, n=n, A = A)

  soln1, soln2 = curve_fit(f=create_fitting_function, xdata=R, ydata=M, p0=[A_initial, q_initial])
  A, q = soln1
  # Now that we obtained A and q, we can use A to obtain K. A is a placeholder 
  # for the constant part of mass-radius relation.
  n = q / (5-q) # one of our conditions
  xi, theta = lane_emden_solver(n)
  # The following are required for the mass calculation
  xi_star = xi[-1]
  theta_dot_xi_star = theta[1, -1]
  G = 6.6743 * 10**-11 
  B = (((n + 1) / (4 * np.pi * G)) ** (((n - 3) / (2 - 2 * n)) + 1.5)) * ((xi_star) ** (((n - 3) / (1 - n)) + 2)) * 4 * np.pi * (-theta_dot_xi_star)

  K = (A / B) ** ((n - 1) / (n))
  print('Estimated parameters for the fitted curve are:')
  print(f'K = {K}\nq = {q}\nA = {A}')


  # We know that q is an integer (from theory). Since we cannot constrain a 
  # fitting parameter to be an integer, we will set q to be the nearest integer 
  # Then, we will do a second fit for the other parameter, K∗. 

  # We had q to be around 3 from the previous part, also the suggestion.

  # Set initial guesses as values obtained from the previous part.
  q_fixed = np.round(q) # integer
  A_new = A

  # Following a similar logic, we fit another curve.

  if (A_new is not None) and (q_fixed is not None):
        def create_fitting_function(R, A_new): 
          n = q_fixed/(5-q_fixed)
          return mass_radius(R = R, n=n, A = A_new)

  soln1_new, soln2_new = curve_fit(f=create_fitting_function, xdata=R, ydata=M, p0=[A_new])
  A2= soln1_new


  n = q_fixed / (5-q_fixed) # one of our conditions
  xi, theta = lane_emden_solver(n)
  # The following are required for the mass calculation
  xi_star = xi[-1]
  theta_dot_xi_star = theta[1, -1]
  G = 6.6743 * 10**-11 
  B = (((n + 1) / (4 * np.pi * G)) ** (((n - 3) / (2 - 2 * n)) + 1.5)) * ((xi_star) ** (((n - 3) / (1 - n)) + 2)) * 4 * np.pi * (-theta_dot_xi_star)
  K_new = (A2 / B) ** ((n - 1) / (n))

  print('Estimated parameters for the fitted curve are:')
  print(f'K = {K_new}\nq = {q_fixed}\nA = {A2}')



fit_curve(low_mass_threshold= 0.34)